# bootstrap

bootstrap the microservice can be done in 3 steps:

## 1. define the service
 

```typescript
interface ServiceDefinition {
  serviceName: string;
  methods: {
    [methodName: string]: {
      asyncModel: AsyncModel;
    };
  };
}
```


```javascript
import { ASYNC_MODEL_TYPES } from '@scalecube/scalecube-microservice';

const serviceDefinition = {
  serviceName: 'Service',
  methods:{
  someMethod : {
    asyncModel : ASYNC_MODEL_TYPES.RequestResponse
    }
  } 
}
```

service definition is the contract between the provider to the consumer of the service.  
in other words, it is the contract that the service must uphold.

  
it is possible that the service will contain more functionality then what you define in the contract,  
but only the functions that are in the definition will be accessible via scalecube.

* serviceName - The name of a service
* methods - Map of methods that exist in the service.  
 each method describe its [asyncModel](#asyncmodel).
 
## 2. create the serviceReference

```javascript
// class example
class Service {
  constructor(){
    
  }
  
  someMethod(){
    return Promise.resolve('some method been resolved');
  }
}
// module example
const someMethod = () => Promise.resolve('some method been resolved');

```

```typescript
type ServiceReference = ServiceFactory | ServiceObject;

type ServiceFactory = ({ createProxy, createServiceCall }: ServiceFactoryOptions) => ServiceObject;

interface ServiceObject {
  constructor?: any;

  [methodName: string]: any;
}

interface ServiceFactoryOptions {
  createProxy: CreateProxy;
  createServiceCall: CreateServiceCall;
}
```
ServiceReference can be a class instance, module or a callback function.

passing callback function in the ServiceReference call [depedency hook](#dependency-hook) 
and it can be used to inject proxy/service call to the service.

## 3. creating microservice

```javascript
import { createMicroservice } from '@scalecube/scalecube-microservice';

const ms = createMicroservice({
             services : [{
               reference : {someMethod},
               definition: serviceDefinition
             },
             {
                reference : new Service(),
                definition: serviceDefinition
              }]
           });
```

```typescript
type CreateMicroservice = (options: MicroserviceOptions) => Microservice;

interface MicroserviceOptions {
  services?: Service[];
  seedAddress?: Address | string;
  address?: Address | string;
  transport?: Transport;
  cluster?: (opt: ClusterOptions) => Cluster;
  debug?: boolean;
 }

interface Service {
  definition: ServiceDefinition;
  reference: ServiceReference;
}
```
After creating a service and a service-definition we can now bootstrap our microservice.   

* services - An array of services, that will exist inside a microservice container.
* seedAddress - [seedAddress](#seedaddress) is the entry point to our distributed env.
* address - An [address](#address) for this microservice instance.
* transport - optional pluggable [transport](#transport).
* cluster - optional pluggable [cluster](#cluster).
* debug - optional logs.

# Basic usage

After bootstrapping the microservice, we can use it to request services from the [distributed environment](#distributed-environment)

## createProxy

```typescript
type CreateProxy = <T = any>(options: ProxyOptions) => T;

interface ProxyOptions {
  router?: Router;
  serviceDefinition: ServiceDefinition;
}

```

```javascript
const serviceProxy = ms.createProxy({serviceDefinition});
serviceProxy.someMethod().then(console.log) // resolve with `someMethod` response
```


It is possible to createProxy from the microservice instance we have just created. 

This is a proxy to a different service that is shared in the [distributed environment](#distributed-environment).

* router - Custom router specifies the logic of choosing the appropriate remoteService.
* serviceDefinition - The metadata for a service container, that includes the name of a service and the map of methods that are included in it.
                         
## createServiceCall

```typescript
type CreateServiceCall = (options: CreateServiceCallOptions) => ServiceCall;

interface CreateServiceCallOptions {
  router?: Router;
}

interface ServiceCall {
  requestStream: (message: Message) => Observable<Message>;
  requestResponse: (message: Message) => Promise<Message>;
}
```

```javascript
const message = {
  qualifier: 'Service/someMethod',
  data: ['value']
};

ms.createServiceCall().requestResponse(message).then(console.log);
ms.createServiceCall().requestStream(message).subscribe(console.log);

```

serviceCall is another way to request a service.  
it is more low level approach and the user must define the [`message`](#message) properly in-order for it to work.

good example for preferring serviceCall over Proxy is in the [`Gateway`](),  
in the Gateway we want to receive a request from outside of our [distributed environment](#distributed-environment) and then pass the request to the correct service inside ot it.

* router - Custom router specifies the logic of choosing the appropriate remoteService
* requestStream - A method using which a consumer requires a stream and receives an Observable sequence describing updates of the method and qualifier that was used for the invocation
* requestResponse - A method using which a consumer requires data and a provider responds with the data once in the form of promise,  
 that includes the response from the method and qualifier that was used for the invocation.

## createProxies

```typescript

type CreateProxies = (options: CreateProxiesOptions) => ProxiesMap;

interface CreateProxiesOptions {
  proxies: ProxiesOptions[];
  router?: Router;
  isAsync?: boolean;
}

interface ProxiesOptions {
  proxyName: string;
  serviceDefinition: ServiceDefinition;
}

interface ProxiesMap {
  [proxyName: string]: Promise<{ proxy: Proxy }> | Proxy;
}

type Proxy<T = any> = T;
```

```javascript
const { awaitServiceProxy } = ms.createProxies({
  proxies: [{
    serviceDefinition,
    proxyName: 'awaitServiceProxy'
  }],
  isAsync : true
});

awaitServiceProxy.then(({proxy: serviceProxy}) => {
  serviceProxy.someMethod().then(console.log);
});
```
createProxies is an advance way of creating a proxy to a service.
it provide a way to receive multiple proxies in one command.  
also, it provide two option of resolving the proxies:

1. if setting the `isAsync` to `true` then you will receive 
an object with Promises to the proxies.

2.  if setting the `isAsync` to `false` then you will receive 
    an object with the proxies.
    
promise to the proxy will resolve only when the service already in the registry.
this help you avoid retry logic till the service is available to use.

* proxies - List of ProxiesOptions, contain the configuration for creating the proxy
* router - optional router to provide extra logic (remoteCall).
* isAsync - optional flag to resolve the proxy asynchronous way  
if true then the proxy will be resolved when the service is in the registry.  
if false then the proxy will be resolved immediately.
* proxyName - name of the proxy (used as the key in the map).
* serviceDefinition - metadata of the service.
* ProxiesMap - Map of generic proxyName and a Promise to the proxy.

## destroy

```typescript
interface Microservice {
  destroy: () => Promise<any>;
}
```

```javascript
ms.destroy().then(console.log);
```
destroy the microservice instance.

1. stop listen to the [address](#address).  
2. notify in the [distributed environment](#distributed-environment) that the services from this microservice are not available anymore.  
3. remove it self from the [distributed environment](#distributed-environment).  

* destroy - The method is used to delete a microservice and close all the subscriptions related with it.

# Advance usage

## remoteCall

```javascript
createMicroservice({
  services: [{
    definition: serviceDefinition,
    reference : new Service()
  }],
  address: 'A'
});

const localMs = createMicroservice({
  seedAddress: 'A'
});

const proxyA = localMs.createProxy({serviceDefinition});

proxyA.someMethod().then(console.log);
```

remoteCall is a request for a service that located in different microservice container in our [distributed environment](#distributed-environment)

## dependency hook

```typescript
type ServiceFactory = ({ createProxy, createServiceCall }: ServiceFactoryOptions) => ServiceObject;

interface ServiceFactoryOptions {
  createProxy: CreateProxy;
  createServiceCall: CreateServiceCall;
}

interface ServiceObject {
  constructor?: any;

  [methodName: string]: any;
}
```

```javascript
import { createMicroservice, ASYNC_MODEL_TYPES } from '@scalecube/scalecube@scalecube/scalecube-microservice';
  const definitionA = {
    serviceName: 'serviceA',
    methods: {
      someMethodA: {
        asyncModel: ASYNC_MODEL_TYPES.REQUEST_RESPONSE,
      },
    },
  };

  const definitionB = {
    serviceName: 'serviceB',
    methods: {
      someMethodB: {
        asyncModel: ASYNC_MODEL_TYPES.REQUEST_RESPONSE,
      },
    },
  };

  class ServiceB {
    constructor(proxyA) {
      // work with proxy to serviceA
      proxyA.someMethodA().then(console.log);
    }
  }
  
createMicroservice({
  services: [
    {
      definition: definitionA,
      reference : { someMethodA}
    },
    {
      definition: definitionB,
      reference: ({ createProxy, createServiceCall }) => {
        const proxyA = createProxy({serviceDefinition: definitionA });
        
        return new ServiceB(proxyA);
      }
    }    
  ]
})
```

dependency hook is used if your service deepened on another service,  
or if you want to add life cycle to your bootstrap process.

## gateway

# Errors

|Error Code | Message | Possible solution | 
| --- | --- | --- |
| MS0000 | microservice does not exists | microservice instance have been destroyed |
| MS0001 | [Message](#message) has not been provided | calling requestResponse or requestStream must contain a Message |
| MS0002 | [Message](#message) data has not been provided | Message must contain data property |
| MS0003 | [Message](#message) qualifier has not been provided | Message must contain qualifier property |
| MS0004 | [Message](#message) should not to be empty object | can not pass empty object as Message |
| MS0005 | [qualifier](#qualifier) expected to be service/method format | qualifier is not a string divided by '/'|
| MS0006 | [Service](#service) missing definition | when [bootstrap microservice](#bootstrap) you provide service without a contract |
| MS0007 | [Message](#message) format error: data must be Array | Message data property must be array, [how can i pass array in message](#passing-array-serviceall)|
| MS0008 | Not valid format, [services](#3-creating-microservice) must be Array | when [bootstrap microservice](#bootstrap), services must be array of service |
| MS0009 | Not valid format, [service](#service) must be Object | service must be an object|
| MS0010 | Not valid format, [Microservice configuration](#microservice) must be an Object | missing configuration when bootstrapping a microservice instance |
| MS0011 | [qualifier](#qualifier) should not be empty string | qualifier must be valid string in the format 'part1/part2'|
| MS0012 | Invalid [createProxies](##createproxies) configuration, proxyName must be unique | when createProxies you are passing the same proxyName twice|
| MS0013 | Transport provider is not define | when running on nodejs, [Transport](#transport) must be provided|
| MS0014 | service method <methodName> missing in the [serviceDefinition](#1-define-the-service) | try to call a method from a proxy that does not in the definition|
| MS0015 | can't find services that match the give criteria: <[qualifier](#qualifier)> | requesting a service that is not in the [registry](#registry)|
| MS0016 | <[asyncModel](#asyncmodel) does not match, expect asyncModel in the proxy definition>, but received <asyncModel in the endpoint definition>| asyncModel in the request does not match the asyncModel define in the registry for the service|
| MS0017 | service (<[qualifier](#qualifier)>) has valid definition but reference is not a function.| [ServiceObject](#2-create-the-servicereference) method is not a function  |
| MS0018 | service does not uphold the contract, <serviceName> is not provided | definition has a method that is not provided in the reference |
| MS0019 | Not valid format, <serviceName> reference must be an Object | [ServiceReference](#2-create-the-servicereference) must return object|
| MS0020 | Invalid format, definition must contain valid serviceName | serviceDefinition must contain property `serviceName` |
| MS0021 | Invalid format, definition must contain valid methods of type object | methods must be of type object |
| MS0022 | Invalid format, definition must contain valid methods | methods must be none empty object |
| MS0023 | Invalid format, serviceName must be not empty string but received type <typeof serviceName> | fix the serviceDefinition, serviceName must be a string |
 
# FAQ

## How can I pass array in message?

```javascript

const arrayToPassInArgs = [1,2,3,4];
const valueToPassInArgs = 5;
const objectToPassInArgs = {'6':6};

const message = {
  qualifier : 'Service/someMethod',
  data: [arrayToPassInArgs, valueToPassInArgs, objectToPassInArgs]
}

```

It is possbile to pass any data structure in the message.  
just need to make sure it wrap in array.


please look at the [example](?javascript#passing-array-argument-in-message)
